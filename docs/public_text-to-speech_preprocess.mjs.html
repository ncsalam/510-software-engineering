<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: public/text-to-speech/preprocess.mjs</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: public/text-to-speech/preprocess.mjs</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Preprocessing utilities used by the Text-To-Speech layer.
 *
 * This module provides helpers that convert timestamps, numbers, currency
 * amounts and long text into forms that are easier and more natural for
 * speech synthesis engines to speak. Functions are written defensively and
 * operate on plain strings.
 *
 * @module src/public/text-to-speech/preprocesss
 */


/**
 * Replace clock/time patterns in `s` with natural spoken equivalents.
 *
 * This function finds common time formats in the input string ("HH:MM AM/PM"
 * and "HH AM/PM", case-insensitive, with optional punctuation like "a.m.")
 * and converts each match into a short phrase suitable for TTS. It leaves
 * other text in `s` unchanged.
 *
 * Examples:
 * - "10:00 PM" -> "ten o'clock pm"
 * - "3:05 a.m." -> "three oh five am"
 * - "7 PM" -> "seven pm"
 *
 * @export
 * @param {string} s - input text
 * @returns {string} transformed text with times expanded for speech
 */
export function englishifyTimes(s) {
  let out = s;

  // "HH:MM AM/PM" (e.g., "10:00 PM", "3:05 a.m.")
  out = out.replace(/\b(\d{1,2}):([0-5]\d)\s*([AaPp])\.?\s*[Mm]\.?\b/g, (_, h, m, ap) => timeToWords(h, m, ap));

  // "HH AM/PM" (e.g., "7 PM", "11 a.m.")
  out = out.replace(/\b(\d{1,2})\s*([AaPp])\.?\s*[Mm]\.?\b/g, (_, h, ap) => timeToWords(h, null, ap));

  return out;
}

/**
 * Convert parsed hour/minute tokens into a spoken time phrase.
 *
 * This internal helper expects strings captured by the regexes in
 * `englishifyTimes` (hour string, minute string or null, and an AM/PM
 * letter). It normalizes the hour into 12-hour form and produces phrases
 * like "seven pm", "ten o'clock pm", or "three oh five am".
 *
 * @param {string} hStr - hour token as matched by the regex (e.g. "3", "10")
 * @param {string|null} mStr - minute token (e.g. "05") or null when absent
 * @param {string} apLetter - single-letter AM/PM marker (case-insensitive)
 * @returns {string} spoken representation suitable for TTS
 */
function timeToWords(hStr, mStr, apLetter) {
  let h = Number(hStr);
  let m = mStr == null ? null : Number(mStr);
  const ap = String(apLetter).toLowerCase() === "p" ? "pm" : "am";

  // Normalize to 12-hour clock for speech
  h = h % 12 || 12;

  const hourWords = numberToWordsUnderBillion(h);
  if (m == null) return `${hourWords} ${ap}`; // "7 PM"
  if (m === 0) return `${hourWords} o'clock ${ap}`; // "10:00 PM"
  if (m &lt; 10) return `${hourWords} oh ${numberToWordsUnderBillion(m)} ${ap}`; // "3:05 am"
  return `${hourWords} ${numberToWordsUnderBillion(m)} ${ap}`; // "12:30 pm"
}

/**
 * Expand numeric tokens, currencies and percentages into words for speech.
 *
 * This function performs three main transformations (in order):
 * 1) Dollar amounts (e.g. "$19.99", "-$123.45") are converted to words
 *    with dollars and cents spelled out.
 * 2) Percentages (e.g. "12.5%", "7%") are expanded to "percent" with
 *    decimal digits read as point-separated digits.
 * 3) Remaining standalone numbers (integers and decimals) are converted
 *    to words. For decimals, the fractional part is read digit-by-digit
 *    after the word "point".
 *
 * The function preserves leading whitespace for dollar/percent matches so
 * the surrounding sentence spacing remains correct.
 *
 * @export
 * @param {string} s - input text
 * @returns {string} transformed text with numeric tokens expanded
 */
export function englishifyNumbers(s) {
  let out = s;

  // 1) Dollar amounts (preserve leading whitespace via capture group 1)
  //    Handles "-$123.45", "$-123.45", "$1,234", "$19.99"
  out = out.replace(/(\s*)(?:-\s*)?\$\s*(?:-\s*)?(\d[\d,]*(?:\.\d+)?)/g, (m, lead, num) => {
    const negative = /-/.test(m);
    const numeric = String(num).replace(/,/g, "");
    const words = dollarsToWords(numeric);
    return lead + (negative ? "minus " : "") + words;
  });

  // 2) Percentages (preserve leading whitespace via capture group 1)
  //    Handles "-12.5%", "7%", "1,200%"
  out = out.replace(/(\s*)(?:-\s*)?(\d[\d,]*(?:\.\d+)?)\s*%/g, (m, lead, num) => {
    const negative = /-/.test(m);
    const numeric = String(num).replace(/,/g, "");
    let words;
    if (numeric.includes(".")) {
      const [i, f] = numeric.split(".");
      const intWords = intToWordsSafe(i);
      const fracWords = f
        .split("")
        .map((d) => digitWord(d))
        .join(" ");
      words = `${intWords} point ${fracWords} percent`;
    } else {
      words = `${intToWordsSafe(numeric)} percent`;
    }
    return lead + (negative ? "minus " : "") + words;
  });

  // 3) Remaining numbers (integers/decimals) â€“ this one never swallows preceding spaces
  out = out.replace(/(?&lt;![A-Za-z])\d[\d,\.]*\d|\b\d\b/g, (numStr) => {
    const hasDot = numStr.includes(".");
    const hasComma = numStr.includes(",");
    let cleaned = numStr;
    if (hasComma &amp;&amp; (!hasDot || /\d,\d{3}(\D|$)/.test(numStr))) {
      cleaned = cleaned.replace(/,/g, "");
    }
    if (cleaned.includes(".")) {
      const [intPart, fracPart] = cleaned.split(".");
      const intWords = intToWordsSafe(intPart);
      const fracWords = (fracPart || "")
        .split("")
        .map((d) => digitWord(d))
        .join(" ");
      return fracPart ? `${intWords} point ${fracWords}` : intWords;
    } else {
      return intToWordsSafe(cleaned);
    }
  });

  return out;
}

/**
 * Convert a numeric dollar amount (no leading "$") into a spoken phrase.
 *
 * The function accepts strings like "123.45" or "0.50" and returns
 * speech-friendly text such as "one hundred twenty-three dollars and
 * forty five cents" or "fifty cents". It handles rounding of fractional
 * cents (e.g., ".999" rounds to the next dollar when appropriate).
 *
 * @export
 * @param {string} numeric - numeric dollar value (no currency symbol)
 * @returns {string} spoken dollar amount
 */
export function dollarsToWords(numeric) {
  const [intPartRaw, fracRaw] = numeric.split(".");
  const intPart = (intPartRaw || "0").replace(/^0+(?!$)/, "");
  let cents = Math.round(Number("0." + (fracRaw || "0")) * 100);
  let dollars = Number(intPart || "0");
  if (cents === 100) {
    dollars += 1;
    cents = 0;
  }

  const dWords = numberToWordsUnderBillion(dollars);
  const dUnit = dollars === 1 ? "dollar" : "dollars";

  if (cents > 0) {
    const cWords = numberToWordsUnderBillion(cents);
    const cUnit = cents === 1 ? "cent" : "cents";
    if (dollars > 0) return `${dWords} ${dUnit} and ${cWords} ${cUnit}`;
    return `${cWords} ${cUnit}`;
  }
  return `${dWords} ${dUnit}`;
}

/**
 * Convert an integer string to English words for numbers up to 999,999,999.
 *
 * For numeric strings longer than 9 digits or non-finite values this
 * function falls back to spelling each digit individually (e.g. "1234567890"
 * -> "one two three ..."). This keeps pronunciations predictable for
 * extremely large inputs.
 *
 * @export
 * @param {string|number} intStr - integer value
 * @returns {string} English words for the integer or digit-spelled fallback
 */
export function intToWordsSafe(intStr) {
  intStr = String(intStr).replace(/^0+(?!$)/, "");
  if (intStr.length > 9) return intStr.split("").map(digitWord).join(" ");
  const n = Number(intStr);
  if (!Number.isFinite(n)) return intStr.split("").map(digitWord).join(" ");
  return numberToWordsUnderBillion(n);
}

/**
 * Return the English word for a single digit character.
 *
 * If input is not a numeric digit this function returns the original
 * character so callers can safely map over mixed input.
 *
 * @param {string|number} d - single digit (e.g. '0'..'9')
 * @returns {string} word for the digit (e.g. 'zero') or the original input
 */
function digitWord(d) {
  return ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"][Number(d)] || d;
}

/**
 * Convert an integer 0..999,999,999 into English words.
 *
 * This is a helper used by `intToWordsSafe` and `dollarsToWords`. It
 * produces compact phrases like "one hundred twenty-three million four
 * hundred fifty-six thousand seven hundred eighty-nine".
 *
 * @param {number} n - integer in range 0..999,999,999
 * @returns {string} English words for `n`
 */
function numberToWordsUnderBillion(n) {
  if (n === 0) return "zero";
  const ones = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  const teens = [
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen",
  ];
  const tens = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];

  function underThousand(x) {
    let out = "";
    const h = Math.floor(x / 100);
    const r = x % 100;
    if (h) out += ones[h] + " hundred";
    if (h &amp;&amp; r) out += " ";
    if (r >= 20) {
      out += tens[Math.floor(r / 10)];
      if (r % 10) out += "-" + ones[r % 10];
    } else if (r >= 10) {
      out += teens[r - 10];
    } else if (r > 0) {
      out += ones[r];
    }
    return out;
  }

  const parts = [];
  const millions = Math.floor(n / 1_000_000);
  const thousands = Math.floor((n % 1_000_000) / 1_000);
  const rest = n % 1_000;
  if (millions) parts.push(underThousand(millions) + " million");
  if (thousands) parts.push(underThousand(thousands) + " thousand");
  if (rest) parts.push(underThousand(rest));
  return parts.join(" ");
}

/**
 * Split text into paragraph-sized chunks for TTS playback.
 *
 * The function first splits the text at blank lines into paragraphs and
 * trims them. Paragraphs shorter than or equal to `maxLen` are returned
 * unchanged. Longer paragraphs are broken into smaller chunks by
 * `splitByLen`, which prefers natural word/punctuation boundaries.
 *
 * @export
 * @param {string} text - input text
 * @param {number} maxLen - maximum allowed chunk length
 * @returns {string[]} array of chunks, each no longer than maxLen (unless a
 * single token exceeds maxLen in which case it will be cut)
 */
export function chunkText(text, maxLen) {
  const paras = text
    .replace(/\r\n/g, "\n")
    .split(/\n{2,}/)
    .map((p) => p.trim())
    .filter(Boolean);

  const out = [];
  for (const p of paras) {
    if (p.length &lt;= maxLen) out.push(p);
    else out.push(...splitByLen(p, maxLen)); // fallback for very long paragraphs
  }
  return out;
}

/**
 * Heuristically split a long string into pieces under `maxLen`.
 *
 * The splitter tokenizes on whitespace and common punctuation then builds
 * chunks by appending tokens until the limit is reached. Very long tokens
 * (longer than `maxLen`) are sliced into `maxLen`-sized pieces.
 *
 * @param {string} s - paragraph to split
 * @param {number} maxLen - maximum chunk length
 * @returns {string[]} array of chunks
 */
function splitByLen(s, maxLen) {
  const parts = [];
  let cur = "";
  const tokens = s.split(/(\s+|,|;|:)/);
  for (const t of tokens) {
    if ((cur + t).length > maxLen) {
      if (cur.trim()) parts.push(cur.trim());
      cur = t.trimStart();
      while (cur.length > maxLen) {
        parts.push(cur.slice(0, maxLen));
        cur = cur.slice(maxLen);
      }
    } else {
      cur += t;
    }
  }
  if (cur.trim()) parts.push(cur.trim());
  return parts;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-app.html">app</a></li><li><a href="module-server_chat-db.html">server/chat-db</a></li><li><a href="module-server_ollama-interface.html">server/ollama-interface</a></li><li><a href="module-server_sqlite3-async.html">server/sqlite3-async</a></li><li><a href="module-server_terminal-helper.html">server/terminal-helper</a></li><li><a href="module-server_validation.html">server/validation</a></li><li><a href="module-src_public_llm_response.html">src/public/llm_response</a></li><li><a href="module-src_public_text-to-speech_preprocesss.html">src/public/text-to-speech/preprocesss</a></li><li><a href="module-src_public_text-to-speech_text-to-speech.html">src/public/text-to-speech/text-to-speech</a></li></ul><h3>Global</h3><ul><li><a href="global.html#wirePage">wirePage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Wed Nov 05 2025 21:38:56 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
